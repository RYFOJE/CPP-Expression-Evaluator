#pragma once
/*!	\file		TestApp.hpp
	\brief		TestApp framework declarations.
	\author		Garth Santor
	\date		2022-11-06
	\copyright	Garth Santor, Trinh Han

=============================================================
TestApp frame declarations.
	TestApp class declaration.
	TestApp::TestCase class declaration.
	TestApp::TestCase::check_equal template implemenation.
	TestApp::TestCase::check_close_epsilon template implemenation.
	GATS_TEST_CASE()
	GATS_TEST_CASE_WEIGHTED()
	GATS_CHECK()
	GATS_CHECK_MESSAGE()
	GATS_CHECK_EQUAL()
	GATS_CHECK_WITHIN()
	GATS_CHECK_THROW()
	GATS_FAIL()

=============================================================
Revision History
-------------------------------------------------------------

2022-11-06
	Changed: macro local variable names to guard against name masking.

2021-11-27
	Added: Groups

Version 2021.10.29
	Added:
		TestApp::current_case()
		GATS_FAIL()
	Changed:
		All macros now make their calls via TestApp::current_case()
		allow for out-of-line use of the CHECK macros.

Version 2021.09.23
	Fixed pass-count in GATS_CHECK_THROW
	Changed stream type from wide to standard.
	Added:
		char_type, ostream_type, ostringstream_type
		GATS_CHECK_MESSAGE
	Refactored internal macro names to 'DETAILED_ ...'
	Replaced some CHECK macros internals with methods
	Formatting: placed quotes around case name in output.
	Added filename to check failure report.

Version 2021.08.29
	Alpha release.

=============================================================

Copyright Garth Santor/Trinh Han

The copyright to the computer program(s) herein
is the property of Garth Santor/Trinh Han, Canada.
The program(s) may be used and/or copied only with
the written permission of Garth Santor/Trinh Han
or in accordance with the terms and conditions
stipulated in the agreement/contract under which
the program(s) have been supplied.
=============================================================*/


#include <gats/ConsoleApp.hpp>

#include <chrono>
#include <cstdint>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <map>
#include <memory>
#include <sstream>
#include <type_traits>
#include <vector>


namespace gats {

	/*!	\brief class TestApp
	
		TestApp singleton class provides a framework for a Windows-based unit-test application. 
	*/
	class TestApp : public ConsoleApp {
	// TYPES
	public:
		using char_type				= char;
		using ostream_type			= std::basic_ostream<char_type>;
		using ofstream_type			= std::basic_ofstream<char_type>;
		using ostringstream_type	= std::basic_ostringstream<char_type>;
		using string_type			= std::basic_string<char_type>;

		/*!	\brief class TestApp::TestCase
			
			TestCase is the base type of classes generated by GATS_TEST_CASE().
			It provides services to the test case that can be accessed via the
			GATS_CHECK macros. */
		class TestCase {
		// ATTRIBUTES
			string_type		name_m;
			string_type		group_m;

			std::chrono::nanoseconds	elapsedTime_m{};
			std::uintmax_t				nChecked_m = 0;
			std::uintmax_t				nPassed_m = 0;

			double			weight_m = 1.0;			// weighted score of this case.

		// VALUES
			static const string_type	defaultGroup_csm;

		// OPERATIONS
		public:
			// Blocked
			TestCase(TestCase const&) = delete;
			void operator = (TestCase const&) = delete;

			// Constructors
			TestCase(string_type const& name, string_type const& group, double weight=1.0);
			TestCase(string_type const& name) : TestCase(name, defaultGroup_csm) {}
			TestCase(string_type const& name, double weight) : TestCase(name, defaultGroup_csm, weight) {}

			// Application Interface
			virtual void execute() = 0;

			// Check Services
			void add_check() { ++nChecked_m; }
			void add_passed() { ++nPassed_m; }
			void output_check_location(ostream_type& _os, std::filesystem::path _file, int _line);
			void check(bool _condition, char_type const * const _condStr, char const * const _file, int _line);
			void check_message(bool _condition, string_type const& _message, char const * const _file, int _line);
			template <typename LHS, typename RHS> 
			void check_equal(LHS const& _lhs, RHS const& _rhs, char_type const* _lhsStr, char_type const* _rhsStr, char const* const _file, int _line);
			template <typename LHS, typename RHS, typename VALUE>
			void check_close_within(LHS const& _lhs, RHS const& _rhs, VALUE const& _minimum, char_type const* _lhsStr, char_type const* _rhsStr, char_type const* _minimumStr, char const* const _file, int _line);

			// Parent Services
			inline ostream_type& display() { return TestApp::display(); }
			inline ostream_type& log() { return TestApp::logFile_m; }

			constexpr auto operator <=> (TestCase const& rhs) const { return name_m <=> rhs.name_m; }
			constexpr bool operator == (TestCase const& rhs) const { return name_m == rhs.name_m; }

			// Access
			friend class TestApp;
		};

	// ATTRIBUTES
	private:
		using case_pointer_type = TestCase*;								/// will point to statically allocated test cases.
		using case_list_type	= std::vector<case_pointer_type>;		
		using case_groups_type	= std::map<string_type, case_list_type>;
		using case_groups_pointer_type = std::unique_ptr<case_groups_type>;

		static case_groups_pointer_type	casesPtr_sm;
		static ofstream_type			logFile_m;
		static case_pointer_type		currentCasePtr_sm;

	// OPERATIONS
		static ostream_type&		display() { return std::cout; }
		static case_groups_type&	cases();

		// Interface
		void setup() override;
		int execute() override;

	public:
		static case_pointer_type current_case(char const* file, int line);
	};


	/*!	\brief Check for value equality.
	
		Check for value equality, reporting if different.
		This function is wrapped by GATS_CHECK_EQUAL() and not called directly.
	*/
	template <typename LHS, typename RHS>
	void TestApp::TestCase::check_equal(LHS const& _lhs, RHS const& _rhs, TestApp::char_type const* _lhsStr, TestApp::char_type const* _rhsStr, char const* const _file, int _line) {
		bool condition = _lhs == _rhs;
		++nChecked_m;
		if (condition == false) {
			ostringstream_type oss;
			output_check_location(oss, _file, _line);
			oss << "\"" << _lhsStr <<  "\" [" << _lhs << "] != \"" << _rhsStr << "\" [" << _rhs << "]\n";
			display() << oss.str();
			//log() << oss.str();
		} else
			++nPassed_m;
	}


	/*!	\brief Check for value closeness.

		Check for real number value similarity as defined by a minimum value, reporting if the difference is
		greater than the minimum.  This function is wrapped by GATS_CHECK_WITHIN() and not called directly.
	*/
	template <typename LHS, typename RHS, typename VALUE>
	void TestApp::TestCase::check_close_within(LHS const& _lhs, RHS const& _rhs, VALUE const& _minimum, char_type const* _lhsStr, char_type const* _rhsStr, char_type const* _minimumStr, char const* const _file, int _line) {
		bool condition = abs((_lhs) - (_rhs)) <= abs(_minimum);
		add_check();
		if (condition == false) {
			ostringstream_type oss;
			output_check_location(oss, _file, _line);
			oss << "difference(" << _lhsStr << ", " << _rhsStr << ") > " << _minimumStr << " ==> \t|" << _lhs << " - " << _rhs << "| > " << abs(_minimum) << "\n";
			display() << oss.str();
			//log() << oss.str();
		} else
			add_passed();
	}

} // end-of-namespace gats



/*!	Creates a test case with the identifier 'name'

	\param 'name' is the test cases identifier.

	The identifier is used to indicate execution order (lexicographical ordering) and both the class and global object name.
*/
#define GATS_TEST_CASE(MACRO_PARAM_GTC_name, ...) \
	static class TestCase_ ## MACRO_PARAM_GTC_name : public gats::TestApp::TestCase {\
	public: TestCase_ ## MACRO_PARAM_GTC_name() : TestCase(#MACRO_PARAM_GTC_name, __VA_ARGS__) { }\
	public: virtual void execute() override;\
	} TestCase_ ## MACRO_PARAM_GTC_name ## _g;\
	void TestCase_ ## MACRO_PARAM_GTC_name :: execute()


/*!	Creates a test case with the identifier 'name'

	\param 'name' is the test cases identifier.

	The identifier is used to indicate execution order (lexicographical ordering) and both the class and global object name.
*/
#define GATS_TEST_CASE_WEIGHTED(MACRO_PARAM_GTCW_name,MACRO_PARAM_GTCW_weight) \
	static class TestCase_ ## MACRO_PARAM_GTCW_name : public gats::TestApp::TestCase {\
	public: TestCase_ ## MACRO_PARAM_GTCW_name() : TestCase(#MACRO_PARAM_GTCW_name,(MACRO_PARAM_GTCW_weight)) { }\
	public: virtual void execute() override;\
	} TestCase_ ## MACRO_PARAM_GTCW_name ## _g;\
	void TestCase_ ## MACRO_PARAM_GTCW_name :: execute()


/*!	Creates a test case with the identifier 'name', and a percentage

	\param 'name' is the test cases identifier.

	The identifier is used to indicate execution order (lexicographical ordering) and both the class and global object name.
*/
#define GATS_TEST_CASE_PERCENTAGE(MACRO_PARAM_GTCP_name, MACRO_PARAM_GTCP_percent) \
	static class TestCase_ ## MACRO_PARAM_GTCP_name : public gats::TestApp::TestCase {\
	public: TestCase_ ## MACRO_PARAM_GTCP_name() : TestCase(#MACRO_PARAM_GTCP_name,1,MACRO_PARAM_GTCP_percent) { }\
	public: virtual void execute() override;\
	} TestCase_ ## MACRO_PARAM_GTCP_name ## _g;\
	void TestCase_ ## MACRO_PARAM_GTCP_name :: execute()


/*!	Performs a check point for the specified condition.

	\param 'cond' is condition that must pass.
*/
#define GATS_CHECK(MACRO_PARAM_GC_condition) gats::TestApp::current_case(__FILE__,__LINE__)->check((MACRO_PARAM_GC_condition), #MACRO_PARAM_GC_condition, __FILE__, __LINE__)


/*!	Performs a check point for the specified condition.

	\param 'cond' is condition that must pass.
*/
#define DETAIL_GATS_CHECK_MESSAGE(MACRO_PARAM_DGCM_condition, MACRO_PARAM_DGCM_message, MACRO_PARAM_DGCM_file, MACRO_PARAM_DGCM_line) {\
	bool MACRO_LOCAL_DGCM_cond = (MACRO_PARAM_DGCM_condition);\
	gats::TestApp::string_type MACRO_LOCAL_DGCM_strMessage;\
	if (MACRO_LOCAL_DGCM_cond == false) {\
		gats::TestApp::ostringstream_type MACRO_LOCAL_DGCM_oss;\
		MACRO_LOCAL_DGCM_oss << MACRO_PARAM_DGCM_message;\
		MACRO_LOCAL_DGCM_strMessage = MACRO_LOCAL_DGCM_oss.str();\
	}\
	gats::TestApp::current_case(__FILE__,__LINE__)->check_message(MACRO_PARAM_DGCM_condition, MACRO_LOCAL_DGCM_strMessage, MACRO_PARAM_DGCM_file, MACRO_PARAM_DGCM_line);\
}
#define GATS_CHECK_MESSAGE(MACRO_PARAM_GCM_condition, MACRO_PARAM_GCM_message) DETAIL_GATS_CHECK_MESSAGE(MACRO_PARAM_GCM_condition, MACRO_PARAM_GCM_message, __FILE__, __LINE__)



/*!	Performs a check that the values are exact matches.

	\param 'testValue' is the value being checked.
	\param 'expectedValue' is the value that the test value should have.
*/
#define GATS_CHECK_EQUAL(MACRO_PARAM_GCE_testValue, MACRO_PARAM_GCE_expectedValue)\
	gats::TestApp::current_case(__FILE__,__LINE__)->check_equal((MACRO_PARAM_GCE_testValue), (MACRO_PARAM_GCE_expectedValue), \
	#MACRO_PARAM_GCE_testValue, #MACRO_PARAM_GCE_expectedValue, __FILE__, __LINE__)



/*!	Performs a check that the values are close matches.

	\param 'testValue' is the value being checked.
	\param 'expectedValue' is the value that the test value should have.
	\param 'minimum' is the maximum difference allowed.
*/
#define GATS_CHECK_WITHIN(MACRO_PARAM_GCW_testValue, MACRO_PARAM_GCW_expectedValue, MACRO_PARAM_GCW_minimum)\
	gats::TestApp::current_case(__FILE__,__LINE__)->check_close_within((MACRO_PARAM_GCW_testValue), (MACRO_PARAM_GCW_expectedValue),\
	(MACRO_PARAM_GCW_minimum), #MACRO_PARAM_GCW_testValue, #MACRO_PARAM_GCW_expectedValue, #MACRO_PARAM_GCW_minimum, __FILE__, __LINE__)



/*!	Performs a check that the values are exact matches.

	\param 'testValue' is the value being checked.
	\param 'expectedValue' is the value that the test value should have.
*/
#define DETAIL_GATS_CHECK_THROW(MACRO_PARAM_DGCT_operation, MACRO_PARAM_DGCT_expectedException, MACRO_PARAM_DGCT_file, MACRO_PARAM_DGCT_line) {\
	gats::TestApp::current_case(__FILE__,__LINE__)->add_check();\
	bool MACRO_LOCAL_DGCT_isGood = false;\
	try {\
		MACRO_PARAM_DGCT_operation;\
	} catch(MACRO_PARAM_DGCT_expectedException) {\
		gats::TestApp::current_case(__FILE__,__LINE__)->add_passed();\
		MACRO_LOCAL_DGCT_isGood = true;\
	} catch(...){\
		gats::TestApp::ostringstream_type MACRO_LOCAL_DGCT_oss;\
		gats::TestApp::current_case(__FILE__,__LINE__)->output_check_location(MACRO_LOCAL_DGCT_oss, (MACRO_PARAM_DGCT_file), (MACRO_PARAM_DGCT_line));\
		MACRO_LOCAL_DGCT_oss << "unknown exception \"" #MACRO_PARAM_DGCT_expectedException "\" not thrown\n";\
		gats::TestApp::current_case(__FILE__,__LINE__)->display() << MACRO_LOCAL_DGCT_oss.str();\
		MACRO_LOCAL_DGCT_isGood = true;\
	}\
	if (!MACRO_LOCAL_DGCT_isGood) {\
		gats::TestApp::ostringstream_type MACRO_LOCAL_DGCT_oss;\
		gats::TestApp::current_case(__FILE__,__LINE__)->output_check_location(MACRO_LOCAL_DGCT_oss, (MACRO_PARAM_DGCT_file), (MACRO_PARAM_DGCT_line));\
		MACRO_LOCAL_DGCT_oss << "no exception thrown, expecting \"" #MACRO_PARAM_DGCT_expectedException "\"\n";\
		gats::TestApp::current_case(__FILE__,__LINE__)->display() << MACRO_LOCAL_DGCT_oss.str();\
	}\
}
#define GATS_CHECK_THROW(MACRO_PARAM_GCT_operation, MACRO_PARAM_GCT_expectedException)\
	DETAIL_GATS_CHECK_THROW(MACRO_PARAM_GCT_operation, MACRO_PARAM_GCT_expectedException, __FILE__, __LINE__)



/*!	Logs a failure in the test case.  Terminating the test case.

	\param 'msg' is the message report.

*/
#define DETAIL_GATS_FAIL(MACRO_PARAM_DGF_msg, MACRO_PARAM_DGF_file, MACRO_PARAM_DGF_line) {\
	gats::TestApp::current_case(__FILE__,__LINE__)->add_check();\
	gats::TestApp::ostringstream_type MACRO_LOCAL_DGF_oss;\
	gats::TestApp::current_case(__FILE__,__LINE__)->output_check_location(MACRO_LOCAL_DGF_oss, MACRO_PARAM_DGF_file, MACRO_PARAM_DGF_line);\
	MACRO_LOCAL_DGF_oss << (MACRO_PARAM_DGF_msg) << '\n';\
	gats::TestApp::current_case(__FILE__,__LINE__)->display() << MACRO_LOCAL_DGF_oss.str();\
	return;\
}
#define GATS_FAIL(MACRO_PARAM_GF_msg) DETAIL_GATS_FAIL(MACRO_PARAM_GF_msg, __FILE__, __LINE__)
